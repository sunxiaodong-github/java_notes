### 类加载

* 在Java代码中，类型的加载、连接和初始化过程都是在程序运行期间完成;
* 提供了更强大的灵活性，增加了更多的可能性。

### 类加载器深入剖析

类加载器用来把类加载到Java虚拟机中。从JDK1.2版本开始，类的加载过程采用父亲委托机制，这种机制能够更好的保证Java平台的安全。
再次委托机制中，除了Java虚拟机自带的根加载器以外，其余的类加载器都有且只有一个父加载器。当Java程序请求加载器loader1加载Sample类时，
loader1首先委托自己的父加载器去加载Sample，若父类加载器能完成加载，则由父类加载器完成任务，
否则才由加载loader1本身加载Sample类。

> Java虚拟机自带了以下几种加载器

* 根（Bootstrap）类加载器：该加载器没有父加载器。负责加载虚拟的核心类库，如java.lang.*等。根加载器从系统属性sun.boot.class.path所指定的目录中加载类库。
根加载器的实现依赖于底层操作系统，属于虚拟机实现的一部分，它并没有继承于java.lang.ClassLoader类。
* 扩展（Extension）类加载器：它的父类加载器为根类加载器。它从java.ext.dirs系统属性所指定的目录中加载类库。或者从JDK的安装目录的jre/lib/ext子目录（扩展目录）
下加载类库，如果把用户创建的JAR文件放到这个目录下，也会自动由扩展类加载器加载。扩展类加载器是纯Java类，是java.lang.ClassLoader类的子类。
* 系统（System）类加载器：也称为应用类加载器，它的父加载器为扩展类加载器。它从环境变量classpath或者系统属性java.class.path所指定的目录中加载类，
它是用户自定义的类加载器的默认父加载器。系统类加载器是纯Java类，是java.lang.ClassLoader类的子类。

> Java虚拟机与程序的生命周期:

* 在如下几种情况下，Java虚拟机将结束生命周期：
    * 执行了System.exit()方法；
    * 程序正常执行结束；
    * 程序在执行过程中遇到了异常或错误而异常终止；
    * 由于操作系统出现错误而导致Java虚拟机进程终止。

### 类加载、连接与初始化

* 加载：查找并加载类的二进制数据；

* 连接：
    * 验证：验证被加载的类的正确性；
    * 准备： 为类的**静态变量**分配内存，并将其初始化为**默认值**；
    * 解析：**把类中的符号引用转换为直接引用。**
    
* **初始化： 为类的静态变量赋予正确的初始值。**

### Java程序对类的使用方式可分为两种

> 主动使用（七种）

1. 创建类的实例（首次使用，只会初始化一次）
2. 访问某个类或接口的静态变量，或者对该静态变量赋值
3. 调用类的静态方法
4. 反射（如：Class.forName("com.java.test.Test")）
5. 初始化一个类的子类
6. Java虚拟机启动时被标明为启动类的类（Java Test）
7. JDK1.7开始提供的动态语言支持java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化。

除了以上7种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化

> 被动使用

所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”才初始化他们

### 类的加载

* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构
* 加载.class文件的方式
    * 从本地系统中直接加载
    * 通过网络下载.class文件
    * 从zip、jar等归档文件中加载.class文件
    * 从专有数据库中提取.class文件
    * 将java源文件动态编译为.class文件

### 类的使用与卸载

* 使用
* 卸载

### 助记符

* ldc：表示将int、float或者是String类型的常量值从常量池中推送至栈顶
* bipush：表示将单个字节（-128~127）的常量值推送至栈顶
* sipush：表示将一个短整型的常量值（-32768 ~ 32767）推送到栈顶
* iconst_1：表示将int类型i推送至栈顶（iconst_1 - iconst_5）
* anewarray：表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶
* newarray：表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶

### 类的验证

* 类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
* 类的验证内容：
    * 类文件的结构检查
    * 语义检查
    * 字节码验证
    * 二进制兼容性的验证
    
### 类的准备

为类变量分配内存，设置默认值。但是在达到初始化之前，类变量都没有初始化为真正的初始值
     
### 类的解析

解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程
     
### 类的初始化

初始化：为类变量赋予正确的初始值；静态变量的声明语句，以及静态代码块都被看做类的初始化语句，Java虚拟机会按照初始化语句在类文件的顺序来依次执行它们。

> 类的初始化步骤

* 假如这个类还没有被加载和连接，那就先进行加载和连接
* 假如类存在直接父类，并且这个父类还没被初始化，那就先初始化直接父类
* 假如类中存在初始化语句，那就依次执行这些初始化语句

> 类的初始化时机

* 当Java虚拟机初始化一个类时，要求它的所有父类都已经被初始化，但是这条规则并不适用于接口。
    * 在初始化一个类时，并不会先初始化它所实现的接口
    * 在初始化一个接口时，并不会初始化它的父接口

因此，一个父接口并不会因为它的子接口或者实现类的初始化而初始化。只有当程序首次使用特定接口的静态变量时，才会导致该接口的初始化。    

* 只有当程序访问的静态变量或静态方法确实在当前类或当前接口中定义时，才可以认为是对类或接口的主动使用。
* 调用ClassLoader类的loadClass方法加载一个类，并不是对类的主动使用，不会导致类的初始化。

> 类实例化：

* 为新的对象分配内存
* 为实例变量赋默认值
* 为实例变量赋正确的初始值
* Java编译器为它编译的每一个类都至少生成一个实例化的方法，在Java的class文件中，这个实例初始化方法被称为"<init>"。针对源代码中每一个类的构造方法，Java编译器都产生一个<init>方法。

### 类的加载

就是把二进制形式的Java类型类型读取入Java虚拟机中

* 类的加载最终产品是位于内存中的Class对象
* Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
* 类加载器并不需要等到某个类被"首次主动使用"时再加载它。
* JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类时才报告错误（LinkageError错误）。
* 如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**。

> 有两种类型的类加载器

* Java虚拟机自带的加载器
    * 根类加载器（Bootstrap）
    * 扩展类加载器（Extension）
    * 系统（应用）类加载器（System）
* 用户定义的类加载器
    * java.lang.ClassLoader的子类
    * 用户可以定制类的加载方式

### 类加载机制的父亲委托机制

父亲委托机制的优点是能够提高软件系统的安全性。因为在此机制下，用户自定义的类加载器不可能加载应该由父类加载器加载的可靠类，从而防止不可靠
甚至恶意的代码代替父加载器加载可靠的代码。例如：java.lang.Object类总是由根类加载器加载，其他任何用户自定义的类加载器都不可能加载含有恶意代码的java.lang.Object类。

根类加载器、扩展类加载器、系统类加载器(应用类加载器)

* Bootstrap ClassLoader /启动类加载器
    * $JAVA_HOME中jre/lib/rt.jar里面所有的class，由C++实现，不是ClassLoader子类。
* Extension ClassLoader /扩展类加载器
    * 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
* App ClassLoader /系统类加载器
    * 负责加载classpath中指定的jar包及目录中class

需要指出的是，加载器之间的父子关系实际上指的是加载器对象之间的包装关系，而不是类之间的继承关系。一对父子加载器可能是同一个加载器类的两个实例，也可能不是。在子加载器类中包装了一个父加载器对象。

> 用户自定义类加载器

* 要创建用户自定义的类加载器，只需要扩展java.lang.ClassLoader类，然后覆盖它的findClass(String name)方法即可，该方法根据参数指定的类的名字，
返回对应的Class对象的引用。 


> 类加载器的双亲委派机制

* 若有一个类加载器能够成功加载Test类，那么这个类加载器被称为定义类加载器，所有成功返回Class对象引用的类加载器（包括定义类加载器）都被称为初始类加载器
* 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器。

### 类的卸载

* 当Sample类被加载、连接和初始化后，它的生命周期就开始了当代表Sample类的Class对象不再被引用，即不可触及时，CLass对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。
* 当一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
* 由java虚拟机自带的类加载的类，在虚拟机的生命周期中，始终不会被卸载。前面已经介绍过。java虚拟机自带的类加载器包括根来加载器、扩展类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的
* 由用户定义的类的类加载器所加载的类是可以被卸载的

### 关于命名空间

* 每个类加载器都有自己的命名空间，**命名空间由该加载器及所有父加载器所加载的类组成**
* 在同一个命名空间中，不会出现类的完整名字（包括类的包名）相同的两个类
* 在不同的命名空间中，有可能会出现类的完整名字（包括类的包名）相同的两个类

> 不同类加载器的命名空间关系

* 同一个命名空间内的类是相互可见的
* 子加载器的命名空间包含所有父加载器的命名空间。因此由子加载器加载的类能看见父加载器加载的类。例如系统类加载器加载的类能看见根加载器加载的类
* 由父加载器加载的类不能看见子类加载器加载的类
* 如果两个加载器之间没有直接或间接的父子关系，那么它们各自加载的类相互不可见

### 类加载器的双亲委派模型的好处

1. 可以确保Java核心库的类型安全；所有的java应用都至少会引用java.lang.Object类，也就是说在运行期，java.lang.Object这个类会被加载到java虚拟机中；
如果这个加载过程是由java应用自己的类加载器所完成的，那么很可能在JVM中存在多个版本的java.lang.Object类，而且这些类还是不兼容的，相互不可见的（正是命名空间在发挥着作用）。
借助于双亲委托机制，java核心类库中的类的加载工作都是由启动类加载器来统一完成，从而确保了java应用所使用的都是同一个版本的java核心类库，他们之间是相互兼容的。
2. 可以确保java核心类库所提供的类不会被自定义的类替代。
3. 不同的类加载器可以被相同名称（binary name）的类创建额外的命名空间，相同名称的类可以并存在java虚拟机中，只需要用不同的类加载器来加载他们即可，不同类加载器所加载的类是不兼容的，
这就相当于在java虚拟机内部创建了一个又一个相互隔离的java类空间，这类技术在很多框架中得到了实际应用。

### Java字节码分析

1. 使用 javap -verbose命令分析一个字节码文件时，将会分析该字节码文件的魔数、版本号、常量池、类信息、类的构造方法信息、类变量与成员变量等信息。
2. 魔数：所有的.class字节码文件的前4个字节都是魔数，魔数值为固定值：0xCAFEBABE。
3. 魔数之后的4个字节是版本信息，前两个字节表示minor version（次版本号），后两个字节表示major version（主版本号），这里的版本信息是
00 00 00 34，换算成十进制，表示次版本号为0，主版本号为52，所以该文件的版本号为1.8.0，可以通过java -version命令验证这点。
4. 常量池（constant pool）：紧接着版本号之后的就是常量池入口，一个Java类中定义的很多信息都是由常量池来维护和描述的。可以将常量池看作是Class文件的资源仓库。
比如说Java类中定义的方法与变量信息，都是存储在常量池中，常量池中主要存储两类常量：子面量和符号引用。字面量如文本字符串，Java中声明为final的常量值等。而符号引用如类和接口的全局限定名，字段的名称和描述符，方法的名称和描述符等。
5. 常量池的总体结构：Java类对应的常量池主要由常量池数量与常量池数组这两部分共同构成。常量池数量紧跟在主版本号后面，占据两个字节；常量池数组则紧跟在常量池之后。
常量池数组与一般的数组不同的是，常量池数组中不同的元素的类型、结构都是不同的，长度当然也就不同；但是，每一个元素的第一个数据都是一个u1类型，该字节是个标志位，占据一个字节。JVM在解析常量池时，会根据这个u1类型来获取元素的具体类型。值得注意的是，常量池数组中元素的个数 = 常量池数 - 1（其中0暂时不使用）
目的是满足某些常量池索引值的数据在特定情况下需要表达【不引用任何一个常量池】的含义；根本原因在于，索引为0也是一个常量（保留常量），只不过它不位于常量表中，这个常量就对应null值；所以常量池的索引从1而非0开始。在JVM规范中，每个变量/字段都有描述信息，描述信息主要的作用是描述字段的数据类型、方法的参数列表（包括数量、类型和顺序）与返回值。根据描述符规则，基本数据类型和代表无返回值的void类型都用一个大写字符来表示，对象类型则使用字符L加对象的全限定名称来表示。为了压缩字节码文件的体积，对于基本数据类型，JVM都只使用一个大写字母来表示，如下所示：B - byte, C - char, D - double, F - float, I - int, J - long, S - short, Z - boolean, V - void, L - 对象类型，如：Ljava/lang/String;
7. 对于数组类型来说，每一个维度使用一个前置的[来表示，如int[]被记录为[I, String[][]被记录为[[Ljava/lang/String;
8. 用描述符描述方法时，按照先参数列表，后返回值的顺序来描述。参数列表按照参数的严格顺序放在一组()之内，如方法：String getRealnameByIdAndNickname(int id, String name)的描述符为：(I, Ljava/lang/String;)Ljava/lang/String;

### Java字节码分析this关键字

对于Java类中的每一个实例方法（非static方法），其在编译后生成的字节码当中，方法参数中的数量总是会比源代码中方法，参数的数量多一个（this），它位于方法参数中的第一个参数位置处；这样我们就可以在Java的实例方法中使用this去访问当前对象的属性以及其他方法。

这个操作是在编译期间完成的，即由javac编译器在编译期间的时候将对this的访问转化为对一个普通实例方法参数的访问；接下来在运行期间，
由jvm在调用实例方法时，自动向该实例方法传入该参数。所以，在实例方法的局部变量表中，至少会有一个指向当前对象的局部变量。

### Java字节码异常处理机制

Java字节码对于异常的处理方式：
1. 统一采用异常表的方式来对异常进行处理
2. 在JDK1.4.2之前的版本中，并不是使用异常表的方式对异常进行处理的，而是采用特定的指令的方式。
3. 当异常处理存在finally语句块时，现在化的JVM采取的处理方式是将finally语句块的字节码拼接到每一个catch块后面，换句话说，程序中存在多少个catch块，就会在每一个catch块后面重复多少个finally语句块的字节码。

### jvm内存划分

* 虚拟机栈：Stack Frame 栈帧
* 程序计数器（Program Counter）
* 本地方法栈：主要用于处理本地方法
* 堆（Heap）：JVM管理的最大一块内存空间，与堆相关的一个重要概念是垃圾收集器。现代几乎所有的垃圾收集器都是采用分代收集算法，
所以堆空间也是基于这一点进行了相应的划分：新生代、老年代。Eden空间、From Survivor空间与To Survivor空间。
* 方法区（Method Area）：存储元信息、永久代（Permanent Generation），从JDK1.8开始，已经彻底废弃了永久代，使用元空间（meta space）
运行时常量池：方法区的一部分内容。
* 直接内存：Direct Memory，与Java NIO密切相关，JVM通过DirectByteBuffer来操作直接内存。

### 关于Java对象创建的过程：

> new关键字创建对象的3个步骤：

1. 在堆内存中创建出对象的实例
2. 为对象的成员变量赋初值
3. 将对象的引用返回

指针碰撞（前提是堆中的空间通过一个指针进行分割，一侧是已经被占用的空间，另一侧是未被占用的空间）
空闲列表（前提是堆内存空间中已被使用的空间是交织在一起的，这时，虚拟机就需要通过一个列表来记录哪些空间是可以使用的，
哪些空间是已被使用的，接下来找出可以容纳下新建对象的且未被使用的空间，在此空间存放该对象，同时还要修改列表上的记录）

> 对象在内存中的布局：

1. 对象头
2. 实例数据（即我们在一个类中所声明的各项信息）
3. 对齐填充（可选）

> 引用访问对象的方式

1. 使用句柄的方式
2. 使用直接指针的方式

### JVM命令分析工具

* jconsole (图形化工具)
* jvisualvm (图形化工具)
* jmap -clstats pid：获取当前运行环境的类加载器
* jstat -gc pid  (MC 当前元空间容量 MU 已占用元空间容量)
* jcmd(jdk7新增) pid VM.flags：查看jvm的启动参数
* jcmd pid help：列出当前运行的java进程可以执行的操作
* jcmd pid help VM.flags：查看具体命令的选项
* jcmd pid PerfCounter.print ：查看JVM性能相关的参数
* jcmd pid VM.uptime：JVM启动时长
* jcmd pid GC.class_histogram：查看系统中类的统计信息
* jcmd pid Thread.print：查看线程的堆栈信息
* jcmd pid GC.heap_dump finename：导出Heap dump文件，导出的文件可以使用jvisualvm查看
* jcmd pid VM.system_properties：查看JVM的属性信息
* jcmd pid VM.command_line：查看JVM启动的命令行参数信息
* jstack：查看或是导出java应用程序中线程的堆栈信息
* jmc：Java Mission Control
* jfr：Flight Record


### JVM运行时内存数据区域

线程共享：方法区域（Method Area）、堆（Heap）
线程隔离：Java虚拟机栈（JVM Stack）、本地方法栈（Native Method Stack）、程序计数器（Program Counter Register）

* Java虚拟机栈（JVM Stack）

    * Java虚拟机栈描述的是Java方法的执行模型：每个方法执行的时候都会创建一个帧（Frame）栈用于存放局部变量表，操作栈，动态链接，方法出口等信息。一个方法的执行过程，就是这个方法对于栈帧的入栈出栈过程。
    * 线程隔离                     
* 堆（Heap）    
    * 堆里存放的是对象的实例
    * 是Java虚拟机管理内存中最大的一块
    * 是GC主要的工作区域，为了高效的GC，会把堆细分更多的子区域
    * 线程共享
* 方法区域（Method Area）
    * 存放每个Class的结构信息，包括常量池、字段描述、方法描述
    * GC的非主要工作区域
    
> JVM运行时内存数据区域-例子

```
public void method(){
    Object obj = new Object();
}
```
* 生成2部分的内存区域 (1)obj这个引用变量，因为是方法内的变量，放到JVM Stack里面；(2)真正Object class的实例对象，放到Heap
* 上述的new语句一共消耗了12个bytes，JVM规定引用占4个字节（在JVM Stack），而空对象是8个bytes（在Heap）
* 方法结束后，对应Stack中的变量马上回收，但是Heap中的对象要等到GC来回收。

### JVM垃圾回收（GC）模型

* 垃圾判断算法（引用计数算法、根搜索算法）
* GC 算法
* 垃圾回收器的实现和选择

> 在Java语言中，GC Root包括

* 在VM栈（帧中的本地变量）中的引用
* 方法区中的静态引用
* JNI（即一般说的Native方法）中的引用

> 方法区

* Java虚拟机规范表示可以不要求虚拟机在这区实现GC，这区GC的"性价比"一般比较低
* 在堆中，尤其是在新生代，常规应用进行一次GC一般可以回收70%～95%的空间，而方法区的GC效率远小于此。
* 当前的商业JVM都有实现方法区的GC，主要回收两部分内容：废弃常量与无用类。
* 类回收需要满足以下3个条件
    * 给类所有的实例都已经被GC，也就是JVM中不存在该Class的任何实例
    * 加载该类的ClassLoader已经被GC
    * 该类对应的java.lang.Class没有在任何地方被引用，如不能在任何地方通过反射访问该类的方法
* 在大量使用反射、动态代理、CGLib等字节码框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要JVM具备类卸载的支持以保证方法区不会溢出。

### JVM常见GC算法

* 标记-清除算法（Mark-Sweep）
* 标记-整理算法（Mark-Compact）
* 复制算法（Copying）
* 分代算法（Generation）
           