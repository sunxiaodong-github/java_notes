## JVM
### 类加载
* 在Java代码中，类型的加载、连接和初始化过程都是在程序运行期间完成;
* 提供了更强大的灵活性，增加了更多的可能性。
### 类加载器深入剖析
* Java虚拟机与程序的生命周期；
* 在如下几种情况下，Java虚拟机将结束生命周期：
    * 执行了System.exit()方法；
    * 程序正常执行结束；
    * 程序在执行过程中遇到了异常或错误而异常终止；
    * 由于操作系统出现错误而导致Java虚拟机进程终止。
### 类加载、连接与初始化
* 加载：查找并加载类的二进制数据；
* 连接：
    * 验证：验证被加载的类的正确性；
    * 准备： 为类的**静态变量**分配内存，并将其初始化为**默认值**；
    * 解析：**把类中的符号引用转换为直接引用。**
* **初始化： 为类的静态变量赋予正确的初始值。**

> Java程序对类的使用方式可分为两种

* 主动使用（七种）
    1. 创建类的实例（首次使用，只会初始化一次）
    2. 访问某个类或接口的静态变量，或者对该静态变量赋值
    3. 调用类的静态方法
    4. 反射（如：Class.forName("com.java.test.Test")）
    5. 初始化一个类的子类
    6. Java虚拟机启动时被标明为启动类的类（Java Test）
    7. JDK1.7开始提供的动态语言支持java.lang.invoke.MethodHandle实例的解析结果REF_getStatic，REF_putStatic，REF_invokeStatic句柄对应的类没有初始化，则初始化。

除了以上7种情况，其他使用java类的方式都被看作是对类的被动使用，都不会导致类的初始化

* 被动使用

> 所有的Java虚拟机实现必须在每个类或接口被Java程序“首次主动使用”才初始化他们

> 类的加载

* 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在内存中创建一个java.lang.Class对象（规范并未说明Class对象位于哪里，HotSpot虚拟机将其放在了方法区中）用来封装类在方法区内的数据结构
* 加载.class文件的方式
    * 从本地系统中直接加载
    * 通过网络下载.class文件
    * 从zip、jar等归档文件中加载.class文件
    * 从专有数据库中提取.class文件
    * 将java源文件动态编译为.class文件

### 类的使用与卸载
* 使用
* 卸载
### 

> 助记符：

* ldc：表示将int、float或者是String类型的常量值从常量池中推送至栈顶
* bipush：表示将单个字节（-128~127）的常量值推送至栈顶
* sipush：表示将一个短整型的常量值（-32768 ~ 32767）推送到栈顶
* iconst_1：表示将int类型i推送至栈顶（iconst_1 - iconst_5）
* anewarray：表示创建一个引用类型的（如类、接口、数组）数组，并将其引用值压入栈顶
* newarray：表示创建一个指定的原始类型（如int、float、char等）的数组，并将其引用值压入栈顶
* 
* 

加载：就是把二进制形式的Java类型类型读取入Java虚拟机中

验证：

准备：为类变量分配内存，设置默认值。但是在达到初始化之前，类变量都没有初始化为真正的初始值

解析：解析过程就是在类型的常量池中寻找类、接口、字段和方法的符号引用，把这些符号引用替换成直接引用的过程

初始化：为类变量赋予正确的初始值

类实例化：
为新的对象分配内存
为实例变量赋默认值
为实例变量赋正确的初始值
Java编译器为它编译的每一个类都至少生成一个实例化的方法，在Java的class文件中，这个实例初始化方法被称为"<init>"。针对源代码中每一个类的构造方法，Java编译器都产生一个<init>方法。

#### 类的加载
* 类的加载最终产品是位于内存中的Class对象
* Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口。
* 类加载器并不需要等到某个类被"首次主动使用"时再加载它。
* JVM规范允许类加载器在预料某个类将要被使用时就预先加载它，如果在预先加载的过程中遇到了.class文件缺失或存在错误，类加载器必须在**程序首次主动**使用该类时才报告错误（LinkageError错误）。
* 如果这个类一直没有被程序主动使用，那么**类加载器就不会报告错误**。

> 有两种类型的类加载器

* Java虚拟机自带的加载器
    * 根类加载器（Bootstrap）
    * 扩展类加载器（Extension）
    * 系统（应用）类加载器（System）
* 用户定义的类加载器
    * java.lang.ClassLoader的子类
    * 用户可以定制类的加载方式
#### 类的验证
* 类被加载后，就进入连接阶段。连接阶段就是将已经读入到内存的类的二进制数据合并到虚拟机的运行时环境中去。
* 类的验证内容：
    * 类文件的结构检查
    * 语义检查
    * 字节码验证
    * 二进制兼容性的验证
#### 类的准备
     
#### 类的初始化


#### 类加载机制的父亲委托机制

根类加载器

扩展类加载器

系统类加载器

* Bootstrap ClassLoader /启动类加载器
    * $JAVA_HOME中jre/lib/rt.jar里面所有的class，由C++实现，不是ClassLoader子类。
* Extension ClassLoader /扩展类加载器
    * 负责加载java平台中扩展功能的一些jar包，包括$JAVA_HOME中jre/lib/*.jar或-Djava.ext.dirs指定目录下的jar包
* App ClassLoader /系统类加载器
    * 负责加载classpath中指定的jar包及目录中class

> 类加载器的双亲委派机制

* 在父亲委托机制中，各个加载器按照父子关系形成了树形结构，除了根类加载器之外，其余的类加载器都有且只有一个父加载器。

#### 类的卸载

* 当Sample类被加载、连接和初始化后，它的生命周期就开始了当代表Sample类的Class对象不再被引用，即不可触及时，CLass对象就会结束生命周期，Sample类在方法区内的数据也会被卸载，从而结束Sample类的生命周期。
* 当一个类何时结束生命周期，取决于代表它的Class对象何时结束生命周期。
* 由java虚拟机自带的类加载的类，在虚拟机的生命周期中，始终不会被卸载。前面已经介绍过。java虚拟机自带的类加载器包括根来加载器、扩展类加载器则会始终引用它们所加载的类的Class对象，因此这些Class对象始终是可触及的
* 由用户定义的类的类加载器所加载的类是可以被卸载的
