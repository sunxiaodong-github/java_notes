## 设计模式

### 单例模式
> 单例模式注意事项和细节说明

* 单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能；
* 当想实例化一个单例的时候，必须要记住使用相应的获取对象的方法，而不是使用new；
* 单例模式使用场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗资源过多（即：重量级对象），但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象（比如：**数据源、session工厂**等）。

### 工厂模式
> 抽象工厂模式

* 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
* 抽象工厂模式可以将简单工厂模式的改进（或者称为进一步的抽象）。
* 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
* 将工厂抽象成两层，AbstractFactory和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类型变成了工厂簇，更利于代码的维护和扩展。

### 原型模式 （浅拷贝、深拷贝）
1. 原型模式是指：用原型实例指定创建对象的种类，并且通过再拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建细节
3. 工作原理是通过将一个原型对象传给那个要发动创建对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实现创建，即：对象.clone()

> 原理结构

1. ProtoType：原型类，声明克隆自己的接口
2. ConcretePrototype：具体的原型类，实现一个克隆自己的操作
3. Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）

**浅拷贝是使用默认的clone()方法实现的**

> 深拷贝

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行可拷贝
3. 深拷贝实现方式：重写clone方法来实现深拷贝
4. 深拷贝实现方式：通过对象序列化实现深拷贝（推荐）

```
// 推荐： 深拷贝 通过对象的序列化
    public Object deepClone(){
        // 创建对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        DeepProtoType copy = null;
        try {
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            copy = (DeepProtoType) ois.readObject();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        return copy;
    }
```

* 创建新的对象比较复杂的时候，可以利用原型模式简化对象的创建过程，同时也能提供效率
* 不用重新初始化对象，而是动态的获得对象运行时的状态
* 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码
* 在实现深克隆的时候可能需要比较复杂的代码
* 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是对已有的类进行改造时，需要修改其源码，违背ocp原则，这点需要注意。

### 建造者模式
1. 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
2. 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。

**建造者模式的四个角色**

* Product（产品角色）：一个具体的产品对象
* Builder（抽象建造者）：创建一个Product对象的各个部件指定的 接口/抽象类
* ConcreteBuilder（具体建造者）：实现接口构建和装配各个部件
* Direct（指挥者）：构建一个使用Builder接口的对象。它主要用于创建一个复杂对象。它主要有两个作用，一是：隔离客户与对象的生产过程，二是：负责控制产品对象的生产过程。

**建造者模式在JDK中的应用和源码分析（StringBuilder）**

> StringBuilder源码中的建造者模式角色分析

1. Appendable 接口定义了多个append方法（抽象方法），即Appendable为抽象建造者，定义了抽象方法
2. AbstractStringBuilder 实现了Appendable接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能实例化
3. StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder

**建造者模式的注意事项和细节**

1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象
3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程
4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
7. 抽象工厂模式 VS 建造者模式：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

### 适配器模式
1. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
2. 适配器模式属于结构型模式
3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式

**适配器模式在 SpringMVC 框架应用的源码剖析**

SpringMvc 中的 HandlerAdapter, 就使用了适配器模式

**适配器模式的注意事项和细节**
1. 三种命名方式，是根据 src 是以怎样的形式给到 Adapter（在 Adapter 里的形式）来命名的。
2.  类适配器：以类给到，在 Adapter 里，就是将 src 当做类，继承
    对象适配器：以对象给到，在 Adapter 里，将 src 作为一个对象，持有
    接口适配器：以接口给到，在 Adapter 里，将 src 作为一个接口，实现
3. Adapter 模式最大的作用还是将原本不兼容的接口融合在一起工作。
4. 实际开发中，实现起来不拘泥于我们讲解的三种经典形式

### 桥接模式
1. 桥接模式(Bridge 模式)是指：将实现与抽象放在两个不同的类层次中，使两个层次可以独立改变。
2. 是一种结构型设计模式
3. Bridge 模式基于类的最小设计原则，通过使用封装、聚合及继承等行为让不同的类承担不同的职责。它的主要特点是把抽象(Abstraction)与行为实现(Implementation)分离开来，从而可以保持各部分的独立性以及应对他们的功能扩展

> 桥接模式在 JDBC 的源码剖析

**桥接模式的注意事项和细节**
1)实现了抽象和实现部分的分离，从而极大的提供了系统的灵活性，让抽象部分和实现部分独立开来，这有助于系统进行分层设计，从而产生更好的结构化系统。
2)对于系统的高层部分，只需要知道抽象部分和实现部分的接口就可以了，其它的部分由具体业务来完成。
3)桥接模式替代多层继承方案，可以减少子类的个数，降低系统的管理和维护成本。

4)桥接模式的引入增加了系统的理解和设计难度，由于聚合关联关系建立在抽象层，要求开发者针对抽象进行设计和编程
5)桥接模式要求正确识别出系统中两个独立变化的维度(抽象、和实现)，因此其使用范围有一定的局限性，即需要有这样的应用场景。

桥接模式其它应用场景

对于那些不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统，桥接模式尤为适用.

> 常见的应用场景:

1)-JDBC 驱动程序
2)-银行转账系统
转账分类: 网上转账，柜台转账，AMT 转账
转账用户类型：普通用户，银卡用户，金卡用户..
3)-消息管理
消息类型：即时消息，延时消息
消息分类：手机短信，邮件消息，QQ 消息...

### 装饰者模式
1)装饰者模式就像打包一个快递
主体：比如：陶瓷、衣服 (Component) // 被装饰者
包装：比如：报纸填充、塑料泡沫、纸板、木板(Decorator)
2)Component 主体：比如类似前面的 Drink
3)ConcreteComponent 和 Decorator
ConcreteComponent：具体的主体， 比如前面的各个单品咖啡
4)Decorator: 装饰者，比如各调料.

> Java 的 IO 结构，FilterInputStream 就是一个装饰者

### 组合模式
1)组合模式（Composite Pattern），又叫部分整体模式，它创建了对象组的树形结构，将对象组合成树状结构以表示“整体-部分”的层次关系。
2)组合模式依据树形结构来组合对象，用来表示部分以及整体层次。
3)这种类型的设计模式属于结构型模式。

组合模式使得用户对单个对象和组合对象的访问具有一致性，即：组合能让客户以一致的方式处理个别对象以及组合对象

**对原理结构图的说明-即(组合模式的角色及职责)**

1)Component :这是组合中对象声明接口，在适当情况下，实现所有类共有的接口默认行为,用于访问和管理Component 子部件, Component可以是抽象类或者接口
2)Leaf : 在组合中表示叶子节点，叶子节点没有子节点
3)Composite :非叶子节点，用于存储子部件，在 Component 接口中实现子部件的相关操作，比如增加(add), 删除。

> Java 的集合类-HashMap 就使用了组合模式

Map(put、putAll)、AbstractMap、HashMap、Node

> 组合模式的注意事项和细节

1)简化客户端操作。客户端只需要面对一致的对象而不用考虑整体部分或者节点叶子的问题。
2)具有较强的扩展性。当我们要更改组合对象时，我们只需要调整内部的层次关系，客户端不用做出任何改动.
3)方便创建出复杂的层次结构。客户端不用理会组合里面的组成细节，容易添加节点或者叶子从而创建出复杂的树形结构
4)需要**遍历组织机构，或者处理的对象具有树形结构时, 非常适合使用组合模式**.
5)要求较高的抽象性，如果节点和叶子有很多差异性的话，比如很多方法和属性都不一样，不适合使用组合模式

### 外观模式
1)外观模式（Facade），也叫“过程模式：外观模式为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用
2)外观模式通过定义一个一致的接口，用以屏蔽内部子系统的细节，使得调用端只需跟这个接口发生调用，而无需关心这个子系统的内部细节

> 分类外观模式的角色

1)外观类(Facade): 为调用端提供统一的调用接口, 外观类知道哪些子系统负责处理请求,从而将调用端的请求代理给适当子系统对象
2)调用者(Client): 外观接口的调用者
3)子系统的集合：指模块或者子系统，处理 Facade 对象指派的任务，他是功能的实际提供者

> 外观模式的注意事项和细节

1)外观模式对外屏蔽了子系统的细节，因此外观模式降低了客户端对子系统使用的复杂性
2)外观模式对客户端与子系统的耦合关系 - 解耦，让子系统内部的模块更易维护和扩展
3)通过合理的使用外观模式，可以帮我们更好的划分访问的层次
4)当系统需要进行分层设计时，可以考虑使用 Facade 模式
5)在维护一个遗留的大型系统时，可能这个系统已经变得非常难以维护和扩展，此时可以考虑为新系统开发一个Facade 类，来提供遗留系统的比较清晰简单的接口，让新系统与 Facade 类交互，提高复用性
6)不能过多的或者不合理的使用外观模式，使用外观模式好，还是直接调用模块好。要以让系统有层次，利于维护为目的。


