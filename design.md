## 设计模式

### 单例模式
> 单例模式注意事项和细节说明

* 单例模式保证了系统内存中只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能；
* 当想实例化一个单例的时候，必须要记住使用相应的获取对象的方法，而不是使用new；
* 单例模式使用场景：需要频繁的进行创建和销毁的对象、创建对象时耗时过多或耗资源过多（即：重量级对象），但又经常用到的对象、**工具类对象**、频繁访问数据库或文件的对象（比如：**数据源、session工厂**等）。

### 工厂模式
> 抽象工厂模式

* 抽象工厂模式：定义了一个interface用于创建相关或有依赖关系的对象簇，而无需指明具体的类
* 抽象工厂模式可以将简单工厂模式的改进（或者称为进一步的抽象）。
* 从设计层面看，抽象工厂模式就是对简单工厂模式的改进（或者称为进一步的抽象）。
* 将工厂抽象成两层，AbstractFactory和具体实现的工厂子类。程序员可以根据创建对象类型使用对应的工厂子类。这样将单个的简单工厂类型变成了工厂簇，更利于代码的维护和扩展。

### 原型模式 （浅拷贝、深拷贝）
1. 原型模式是指：用原型实例指定创建对象的种类，并且通过再拷贝这些原型，创建新的对象
2. 原型模式是一种创建型设计模式，允许一个对象再创建另外一个可定制的对象，无需知道如何创建细节
3. 工作原理是通过将一个原型对象传给那个要发动创建对象，这个要发动创建的对象通过请求原型对象拷贝它们自己来实现创建，即：对象.clone()

> 原理结构

1. ProtoType：原型类，声明克隆自己的接口
2. ConcretePrototype：具体的原型类，实现一个克隆自己的操作
3. Client：让一个原型对象克隆自己，从而创建一个新的对象（属性一样）

**浅拷贝是使用默认的clone()方法实现的**

> 深拷贝

1. 复制对象的所有基本数据类型的成员变量值
2. 为所有引用数据类型的成员变量申请存储空间，并复制每个引用数据类型成员变量所引用的对象，直到该对象可达的所有对象。也就是说，对象进行深拷贝要对整个对象进行可拷贝
3. 深拷贝实现方式：重写clone方法来实现深拷贝
4. 深拷贝实现方式：通过对象序列化实现深拷贝（推荐）

```
// 推荐： 深拷贝 通过对象的序列化
    public Object deepClone(){
        // 创建对象
        ByteArrayOutputStream bos = null;
        ObjectOutputStream oos = null;
        ByteArrayInputStream bis = null;
        ObjectInputStream ois = null;
        DeepProtoType copy = null;
        try {
            // 序列化
            bos = new ByteArrayOutputStream();
            oos = new ObjectOutputStream(bos);
            oos.writeObject(this);

            // 反序列化
            bis = new ByteArrayInputStream(bos.toByteArray());
            ois = new ObjectInputStream(bis);
            copy = (DeepProtoType) ois.readObject();
        }catch (Exception e){
            e.printStackTrace();
        }finally {
            try {
                bos.close();
                oos.close();
                bis.close();
                ois.close();
            }catch (Exception e){
                e.printStackTrace();
            }
        }
        return copy;
    }
```

* 创建新的对象比较复杂的时候，可以利用原型模式简化对象的创建过程，同时也能提供效率
* 不用重新初始化对象，而是动态的获得对象运行时的状态
* 如果原始对象发生变化（增加或者减少属性），其他克隆对象的也会发生相应的变化，无需修改代码
* 在实现深克隆的时候可能需要比较复杂的代码
* 缺点：需要为每一个类配备一个克隆方法，这对全新的类来说不是很难，但是对已有的类进行改造时，需要修改其源码，违背ocp原则，这点需要注意。

### 建造者模式
1. 建造者模式（Builder Pattern） 又叫生成器模式，是一种对象构建模式。它可以将复杂对象的建造过程抽象出来（抽象类别），使这个抽象过程的不同实现方法可以构造出不同表现（属性）的对象。
2. 建造者模式 是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们， 用户不需要知道内部的具体构建细节。

**建造者模式的四个角色**

* Product（产品角色）：一个具体的产品对象
* Builder（抽象建造者）：创建一个Product对象的各个部件指定的 接口/抽象类
* ConcreteBuilder（具体建造者）：实现接口构建和装配各个部件
* Direct（指挥者）：构建一个使用Builder接口的对象。它主要用于创建一个复杂对象。它主要有两个作用，一是：隔离客户与对象的生产过程，二是：负责控制产品对象的生产过程。

**建造者模式在JDK中的应用和源码分析（StringBuilder）**

> StringBuilder源码中的建造者模式角色分析

1. Appendable 接口定义了多个append方法（抽象方法），即Appendable为抽象建造者，定义了抽象方法
2. AbstractStringBuilder 实现了Appendable接口方法，这里的AbstractStringBuilder 已经是建造者，只是不能实例化
3. StringBuilder 即充当了指挥者角色，同时充当了具体的建造者，建造方法的实现是由AbstractStringBuilder完成，而StringBuilder继承了AbstractStringBuilder

**建造者模式的注意事项和细节**

1. 客户端(使用程序)不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象
2. 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象
3. 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰， 也更方便使用程序来控制创建过程
4. 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”
5. 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
6. 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，因此在这种情况下，要考虑是否选择建造者模式.
7. 抽象工厂模式 VS 建造者模式：抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式不需要关心构建过程，只关心什么产品由什么工厂生产即可。而建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品

### 适配器模式
1. 适配器模式(Adapter Pattern)将某个类的接口转换成客户端期望的另一个接口表示，主的目的是兼容性，让原本因接口不匹配不能一起工作的两个类可以协同工作。其别名为包装器(Wrapper)
2. 适配器模式属于结构型模式
3. 主要分为三类：类适配器模式、对象适配器模式、接口适配器模式